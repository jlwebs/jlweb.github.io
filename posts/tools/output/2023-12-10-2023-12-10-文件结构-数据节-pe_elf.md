---
layout: post
title: "2023-12-10-文件结构-数据节-pe_elf"
date: 2023-12-10
categories: jekyll
tags: ['output']
comments: true
---

---
layout: post
title: "文件结构 数据节 PE_ELF"
date: 2023-12-10
categories: jekyll
tags: ['🥁-OS']
comments: true
---

### 1.ELF
段名	内容
.text	存放编译生成的机器码
.rodata	存放只读数据，一般是程序中的只读静态变量和字符串常量
.data	保存已经初始化的全局静态变量和局部静态变量
.bss	存储未初始化以及初始化为0的全局静态变量和局部静态变量
.rodata1	也是只读数据段，存放字符串常量，全局 const 变量，该段和 .rodata 类似。
.comment	存放编译器版本信息，比如 “GCC:GNU4.2.0”
.debug	调试信息
.dynamic	动态链接信息
.hash	符号哈希表
.line	调试时的行号表，即源代码行号与编译后指令的对应表
.note	额外的编译器信息，比如程序的公司名、发布版本号等
.strtab	String Table 字符串表，用于存储 ELF 文件中用到的各种字符串
.symtab	Symbol Table 符号表，从这里可以找到文件中的各个符号
.shstrtab	各个段的名称表，实际上是由各个段的名字组成的一个字符串数组
.plt 和 .got	动态链接的跳转表和全局入口表
.init 和 .fini	程序初始化和终结代码段
### 2.PE WIN32
.text - 不多说了，就是保存代码的节
.data - 保存数据的节，这个对应C语言中以初始化的全局变量数据。想想为什么你在源码里初始化一个全局变量后运行时这个变量的值正是你想要的那个？int a = 12;并不意味着CRT为你执行了一个赋值语句，而是a在PE文件中保存的位置已经被硬编码了一个12的值。这样loader加载程序时，你给的初值被从PE文件读取到了内存中变量a的位置，这样才使你的变量a有了初值。
.rdata - 保存常量数据的节。这个可以对应C语言中的常数和常量字符串，同上面一样的原因，他们的初值被保存到了PE文件的次Section中，而不是在运行时被赋值。
.bss - (Block Start with Symbol)这个section对应C程序中的全局未初始化变量。啥？你说C中未初始化的全局变量实际上全被初始化成了0？这是因为实际上操作系统是这样干的——你的全局未初始化变量由于没有初值，所以不需要将值像上面两个一样保存到PE文件中（所以.bss节除了描述信息之外不占据磁盘空间），但是.bss会描述一段内存区域，loader在加载.bss section时直接开辟这么一块包括所有未初始化数据的内存区域，然后直接将这区域清零。这就是C中全局未初始化数据之所以为零的原因了。
.idata - 这个是保存程序导入表(Import Table)的节。当然，IT、ILT以及IAT也常常被保存在.rdata中，为什么？是考虑到安全的因素，所以将IAT放在不可写的.rdata里以防止IAT被恶意更改从而造成程序的安全隐患吧。
.edata - 这个是保存导处表的(Export Table)的节。
.reloc - 这个节是保存重定位数据的
.rsrc - 这节是保存程序资源的。想你的程序字符串啊、对话框模板啊、位图、鼠标光标什么的都在这里。实际上这个节储存.resx文件编译后的结果。
.textbss - 这节比较好玩，它是和微软Incremental Linking(增量链接)特性相关的。
